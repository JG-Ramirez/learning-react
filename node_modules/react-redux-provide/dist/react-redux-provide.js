(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("redux"), require("redux-replicate"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "redux", "redux-replicate"], factory);
	else if(typeof exports === 'object')
		exports["ReactReduxProvide"] = factory(require("react"), require("redux"), require("redux-replicate"));
	else
		root["ReactReduxProvide"] = factory(root["React"], root["Redux"], root["ReduxReplicate"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_12__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unshiftClear = exports.pushClear = exports.unshiftWait = exports.pushWait = exports.unshiftReplicator = exports.pushReplicator = exports.unshiftReplication = exports.pushReplication = exports.unshiftOnReady = exports.pushOnReady = exports.unshiftOnInstantiated = exports.pushOnInstantiated = exports.unshiftEnhancer = exports.pushEnhancer = exports.unshiftMiddleware = exports.pushMiddleware = exports.handleQueries = exports.getMergedResult = exports.getQueryHandlers = exports.getQueriesOptions = exports.getQueryOptions = exports.getQuery = exports.getQueries = exports.getFunctionOrObject = exports.getQueryResults = exports.getActiveQueries = exports.getProviderInstances = exports.getProviders = exports.getFromContextOrProps = exports.instantiateProvider = exports.shallowEqual = exports.createKeyConcat = exports.getInitialState = exports.getClientState = exports.createProviderStore = exports.reloadProviders = exports.reloadFunctions = exports.provide = undefined;

	var _provide = __webpack_require__(7);

	var _provide2 = _interopRequireDefault(_provide);

	var _createProviderStore = __webpack_require__(3);

	var _createProviderStore2 = _interopRequireDefault(_createProviderStore);

	var _createKeyConcat = __webpack_require__(2);

	var _createKeyConcat2 = _interopRequireDefault(_createKeyConcat);

	var _shallowEqual = __webpack_require__(1);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _instantiateProvider = __webpack_require__(5);

	var _instantiateProvider2 = _interopRequireDefault(_instantiateProvider);

	var _keyConcats = __webpack_require__(6);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _provide2.default;
	exports.provide = _provide2.default;
	exports.reloadFunctions = _provide.reloadFunctions;
	exports.reloadProviders = _provide.reloadProviders;
	exports.createProviderStore = _createProviderStore2.default;
	exports.getClientState = _createProviderStore.getClientState;
	exports.getInitialState = _createProviderStore.getInitialState;
	exports.createKeyConcat = _createKeyConcat2.default;
	exports.shallowEqual = _shallowEqual2.default;
	exports.instantiateProvider = _instantiateProvider2.default;
	exports.getFromContextOrProps = _instantiateProvider.getFromContextOrProps;
	exports.getProviders = _instantiateProvider.getProviders;
	exports.getProviderInstances = _instantiateProvider.getProviderInstances;
	exports.getActiveQueries = _instantiateProvider.getActiveQueries;
	exports.getQueryResults = _instantiateProvider.getQueryResults;
	exports.getFunctionOrObject = _instantiateProvider.getFunctionOrObject;
	exports.getQueries = _instantiateProvider.getQueries;
	exports.getQuery = _instantiateProvider.getQuery;
	exports.getQueryOptions = _instantiateProvider.getQueryOptions;
	exports.getQueriesOptions = _instantiateProvider.getQueriesOptions;
	exports.getQueryHandlers = _instantiateProvider.getQueryHandlers;
	exports.getMergedResult = _instantiateProvider.getMergedResult;
	exports.handleQueries = _instantiateProvider.handleQueries;
	exports.pushMiddleware = _keyConcats.pushMiddleware;
	exports.unshiftMiddleware = _keyConcats.unshiftMiddleware;
	exports.pushEnhancer = _keyConcats.pushEnhancer;
	exports.unshiftEnhancer = _keyConcats.unshiftEnhancer;
	exports.pushOnInstantiated = _keyConcats.pushOnInstantiated;
	exports.unshiftOnInstantiated = _keyConcats.unshiftOnInstantiated;
	exports.pushOnReady = _keyConcats.pushOnReady;
	exports.unshiftOnReady = _keyConcats.unshiftOnReady;
	exports.pushReplication = _keyConcats.pushReplication;
	exports.unshiftReplication = _keyConcats.unshiftReplication;
	exports.pushReplicator = _keyConcats.pushReplicator;
	exports.unshiftReplicator = _keyConcats.unshiftReplicator;
	exports.pushWait = _keyConcats.pushWait;
	exports.unshiftWait = _keyConcats.unshiftWait;
	exports.pushClear = _keyConcats.pushClear;
	exports.unshiftClear = _keyConcats.unshiftClear;

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }

	  if (!objA || (typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || !objB || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object') {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createKeyConcat;
	function createKeyConcat(keys, unshift) {
	  var key = keys;
	  var getTarget = function getTarget(provider) {
	    return provider;
	  };

	  if (Array.isArray(keys)) {
	    keys = [].concat(keys);
	    key = keys.pop();
	    getTarget = function getTarget(provider) {
	      return keys.reduce(function (obj, key) {
	        return obj[key];
	      }, provider);
	    };
	  }

	  return function (providers, value) {
	    for (var providerKey in providers) {
	      var target = getTarget(providers[providerKey]);

	      if (target) {
	        if (!target[key]) {
	          target[key] = [];
	        } else if (!Array.isArray(target[key])) {
	          target[key] = [target[key]];
	        }

	        if (unshift) {
	          target[key] = [].concat(value).concat(target[key]);
	        } else {
	          target[key] = target[key].concat(value);
	        }
	      }
	    }
	  };
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.getClientState = getClientState;
	exports.getInitialState = getInitialState;
	exports.default = createProviderStore;

	var _redux = __webpack_require__(11);

	var _reduxReplicate = __webpack_require__(12);

	var _reduxReplicate2 = _interopRequireDefault(_reduxReplicate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function getClientState(_ref) {
	  var providerKey = _ref.providerKey;

	  if (typeof window !== 'undefined' && window.clientStates) {
	    var clientState = window.clientStates[providerKey];

	    if (typeof clientState !== 'undefined') {
	      return clientState;
	    }
	  }

	  return null;
	}

	function getInitialState(_ref2) {
	  var providerKey = _ref2.providerKey;
	  var state = _ref2.state;

	  var clientState = getClientState({ providerKey: providerKey, state: state });

	  if (clientState) {
	    delete window.clientStates[providerKey];

	    return state ? _extends({}, state, clientState) : clientState;
	  }

	  return state || {};
	}

	/**
	 * Creates and returns a store specifically for some provider instance.
	 *
	 * @param {Object} providerInstance
	 * @param {Mixed} storeKey Optional
	 * @param {Object} createState Optional
	 * @param {Function} createFunction Optional
	 * @param {Object} creatorStore Optional
	 * @return {Object}
	 * @api public
	 */
	function createProviderStore(providerInstance, storeKey, createState, createFunction, creatorStore) {
	  var reducers = providerInstance.reducers;
	  var middleware = providerInstance.middleware;
	  var enhancer = providerInstance.enhancer;
	  var replication = providerInstance.replication;

	  var watchedReducers = {};
	  var watching = {};
	  var enhancers = [];
	  var create = void 0;
	  var store = void 0;
	  var setState = void 0;
	  var settingState = void 0;
	  var combinedReducers = void 0;

	  if (typeof storeKey === 'undefined') {
	    storeKey = providerInstance.providerKey;
	  }

	  function unshiftReplication(_ref3) {
	    var key = _ref3.key;
	    var reducerKeys = _ref3.reducerKeys;
	    var queryable = _ref3.queryable;
	    var baseQuery = _ref3.baseQuery;
	    var replicator = _ref3.replicator;

	    if (replicator) {
	      if (baseQuery) {
	        if (Array.isArray(reducerKeys)) {
	          for (var reducerKey in baseQuery) {
	            if (reducerKeys.indexOf(reducerKey) < 0) {
	              reducerKeys.push(reducerKey);
	            }
	          }
	        }

	        if (Array.isArray(queryable)) {
	          for (var _reducerKey in baseQuery) {
	            if (queryable.indexOf(_reducerKey) < 0) {
	              queryable.push(_reducerKey);
	            }
	          }
	        }
	      }

	      enhancers.unshift((0, _reduxReplicate2.default)({
	        key: typeof key === 'undefined' ? storeKey : key,
	        reducerKeys: reducerKeys,
	        queryable: queryable,
	        replicator: replicator,
	        create: createFunction || Boolean(createState),
	        clientState: getClientState(providerInstance),
	        creatorStore: creatorStore
	      }));
	    }
	  }

	  if (middleware) {
	    enhancers.push(_redux.applyMiddleware.apply(null, [].concat(middleware)));
	  }

	  if (enhancer) {
	    enhancers = enhancers.concat(enhancer);
	  }

	  if (replication) {
	    if (Array.isArray(replication)) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = replication[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value.key;

	          if (typeof key !== 'undefined') {
	            storeKey = key;
	            break;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      replication.forEach(unshiftReplication);
	    } else {
	      unshiftReplication(replication);
	    }
	  }

	  if (enhancers.length) {
	    create = _redux.compose.apply(undefined, _toConsumableArray(enhancers))(_redux.createStore);
	  } else {
	    create = _redux.createStore;
	  }

	  var initialState = {};
	  var preInitialState = _extends({}, createState || getInitialState(providerInstance));

	  Object.keys(reducers).forEach(function (reducerKey) {
	    if (typeof preInitialState[reducerKey] !== 'undefined') {
	      initialState[reducerKey] = preInitialState[reducerKey];
	    }

	    watchedReducers[reducerKey] = function (state, action) {
	      var nextState = void 0;

	      if (settingState && typeof settingState[reducerKey] !== 'undefined') {
	        nextState = settingState[reducerKey];
	      } else {
	        nextState = reducers[reducerKey](state, action);
	      }

	      if (watching[reducerKey] && state !== nextState) {
	        watching[reducerKey].forEach(function (fn) {
	          return fn(nextState);
	        });
	      }

	      return nextState;
	    };
	  });

	  combinedReducers = (0, _redux.combineReducers)(watchedReducers);
	  store = create(combinedReducers, initialState);

	  // we use a custom `watch` method with instead of a replicator
	  // since it's slightly more efficient and every clock cycle counts,
	  // especially with potentially thousands or even millions of components
	  store.watch = function (reducerKey, fn) {
	    if (!watching[reducerKey]) {
	      watching[reducerKey] = new Set();
	    }

	    watching[reducerKey].add(fn);

	    return function () {
	      return watching[reducerKey].delete(fn);
	    };
	  };

	  setState = store.setState;
	  store.setState = function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var nextState = args[0];

	    var state = store.getState();

	    if (setState) {
	      var _loop = function _loop(reducerKey) {
	        var current = state[reducerKey];
	        var next = nextState[reducerKey];

	        if (watching[reducerKey] && current !== next) {
	          watching[reducerKey].forEach(function (fn) {
	            return fn(next);
	          });
	        }
	      };

	      for (var reducerKey in nextState) {
	        _loop(reducerKey);
	      }

	      setState.apply(undefined, args);
	    } else {
	      settingState = nextState;
	      store.replaceReducer(combinedReducers);
	      settingState = null;
	    }
	  };

	  return store;
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = getRelevantKeys;
	function getRelevantKeys() {
	  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var relevantKeys = [];

	  if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
	    for (var key in b) {
	      if (key in a) {
	        relevantKeys.push(key);
	      }
	    }
	  }

	  return relevantKeys;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = instantiateProvider;
	exports.getTempFauxInstance = getTempFauxInstance;
	exports.getFromContextOrProps = getFromContextOrProps;
	exports.getProviders = getProviders;
	exports.getProviderInstances = getProviderInstances;
	exports.getActiveQueries = getActiveQueries;
	exports.getQueryResults = getQueryResults;
	exports.getPartialStates = getPartialStates;
	exports.getFunctionOrObject = getFunctionOrObject;
	exports.getQueries = getQueries;
	exports.getQuery = getQuery;
	exports.getQueryOptions = getQueryOptions;
	exports.getQueriesOptions = getQueriesOptions;
	exports.getQueryHandlers = getQueryHandlers;
	exports.getMergedResult = getMergedResult;
	exports.resultsEqual = resultsEqual;
	exports.handleQueries = handleQueries;

	var _shallowEqual = __webpack_require__(1);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _getRelevantKeys = __webpack_require__(4);

	var _getRelevantKeys2 = _interopRequireDefault(_getRelevantKeys);

	var _createProviderStore = __webpack_require__(3);

	var _createProviderStore2 = _interopRequireDefault(_createProviderStore);

	var _keyConcats = __webpack_require__(6);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var isServerSide = typeof window === 'undefined';
	var isTesting = typeof process !== 'undefined' && process.env && ("development") === 'test';

	var globalProviderInstances = {};

	// TODO: we'll use this at some point to select only component propTypes
	/*
	function hasReducerKeys(providerInstance, getReducerKeys) {
	  if (!getReducerKeys) {
	    return true;
	  }

	  const { hasReducerKeys = {} } = providerInstance;

	  for (let reducerKey in getReducerKeys) {
	    if (!hasReducerKeys[reducerKey]) {
	      providerInstance.hasReducerKeys = {
	        ...hasReducerKeys,
	        ...getReducerKeys
	      };

	      return false;
	    }
	  }

	  return true;
	}*/

	/**
	 * Instantiates a provider with its own store.
	 *
	 * @param {Object} fauxInstance resembles { props, context }
	 * @param {Object} provider
	 * @param {String|Function} providerKey Optional
	 * @param {Function} readyCallback Optional
	 * @param {Object} createState Optional
	 * @param {Object} getReducerKeys Optional
	 * @return {Object}
	 * @api public
	 */
	function instantiateProvider(fauxInstance, provider, providerKey, readyCallback, createState, getReducerKeys) {
	  if (arguments.length === 1) {
	    fauxInstance = arguments[0].fauxInstance;
	    provider = arguments[0].provider;
	    providerKey = arguments[0].providerKey;
	    readyCallback = arguments[0].readyCallback;
	    createState = arguments[0].createState;
	    getReducerKeys = arguments[0].getReducerKeys;

	    if (!fauxInstance) {
	      provider = arguments[0];
	      fauxInstance = {};
	    }
	  }

	  if (!fauxInstance.props) {
	    fauxInstance.props = {};
	  }

	  if (typeof providerKey === 'undefined') {
	    providerKey = provider.key;
	  }

	  if (!provider.actions) {
	    provider.actions = {};
	  }
	  if (!provider.reducers) {
	    provider.reducers = {};
	  }

	  if (getReducerKeys === true) {
	    getReducerKeys = provider.reducers;
	  }

	  var providers = getProviders(fauxInstance);
	  var providerInstances = getProviderInstances(fauxInstance);
	  var providerInstance = void 0;
	  var isStatic = typeof providerKey !== 'function';
	  var storeKey = void 0;
	  var creator = void 0;

	  if (typeof provider.key === 'string') {
	    if (!providers[provider.key]) {
	      providers[provider.key] = provider;
	    }
	  } else if (provider.defaultKey) {
	    if (!providers[provider.defaultKey]) {
	      providers[provider.defaultKey] = provider;
	    }
	  } else if (!provider.key || !provider.key.toString) {
	    console.warn('Missing or invalid provider key!');
	  } else if (!providers[provider.key.toString()]) {
	    providers[provider.key.toString()] = provider;
	  }

	  if (!isStatic) {
	    // get actual `providerKey`
	    providerKey = providerKey(fauxInstance);
	    // if actual `providerKey` matches `key`, treat as static provider
	    isStatic = providerKey === provider.key;
	  }

	  if (providerKey === null) {
	    storeKey = null;
	    providerKey = provider.defaultKey;
	    isStatic = true;
	  }

	  providerInstance = provider.isGlobal ? globalProviderInstances[providerKey] : providerInstances && providerInstances[providerKey];

	  if (fauxInstance.relevantProviders) {
	    fauxInstance.relevantProviders[providerKey] = true;
	  }

	  // TODO: we'll use this at some point
	  //if (providerInstance && hasReducerKeys(providerInstance, getReducerKeys)) {
	  if (providerInstance) {
	    if (createState) {
	      creator = providerInstance;
	    } else {
	      if (readyCallback) {
	        if (providerInstance.ready) {
	          readyCallback(providerInstance);
	        } else {
	          (0, _keyConcats.pushOnReady)({ providerInstance: providerInstance }, readyCallback);
	        }
	      }

	      providerInstances[providerKey] = providerInstance;
	      return providerInstance;
	    }
	  }

	  if (!provider.hasThunk) {
	    (function () {
	      var findProvider = function findProvider(props) {
	        if ((0, _getRelevantKeys2.default)(provider.reducers, props).length) {
	          return provider;
	        }

	        for (var key in providers) {
	          if ((0, _getRelevantKeys2.default)(providers[key].reducers, props).length) {
	            return providers[key];
	          }
	        }

	        return provider;
	      };

	      var getResultInstances = function getResultInstances(result, callback) {
	        var resultInstances = [];
	        var semaphore = result && result.length;
	        function clear() {
	          if (--semaphore === 0) {
	            callback(resultInstances);
	          }
	        }

	        if (!semaphore) {
	          semaphore = 1;
	          clear();
	          return;
	        }

	        result.forEach(function (resultProps, index) {
	          resultInstances[index] = null;

	          instantiateProvider(getTempFauxInstance(fauxInstance, resultProps), findProvider(resultProps), undefined, function (resultInstance) {
	            resultInstances[index] = resultInstance;
	            clear();
	          });
	        });
	      };

	      var getInstance = function getInstance(props, callback, create) {
	        var provider = void 0;
	        var providerKey = void 0;

	        if (typeof props === 'string') {
	          // key is already known
	          if (providerInstances[props]) {
	            providerKey = props;
	          }

	          provider = providers[props] || providerInstances[props];
	          props = {};
	        } else {
	          provider = findProvider(props);
	        }

	        return instantiateProvider(getTempFauxInstance(fauxInstance, props), provider, providerKey, callback, create ? props : null);
	      };

	      var getInstances = function getInstances(propsArray, callback, create) {
	        var instances = [];
	        var getCount = propsArray.length;
	        var clear = function clear() {
	          if (--getCount === 0) {
	            if (callback) {
	              callback(instances);
	            }
	          }
	        };

	        propsArray.forEach(function (props, index) {
	          getInstance(props, function (instance) {
	            instances[index] = instance;
	            clear();
	          }, create);
	        });

	        return instances;
	      };

	      var createInstance = function createInstance(props, callback) {
	        return getInstance(props, callback, true);
	      };

	      var createInstances = function createInstances(propsArray, callback) {
	        return getInstances(propsArray, callback, true);
	      };

	      var setStates = function setStates(states) {
	        var gettingInstances = [];
	        var settingStates = [];
	        var clientStates = null;

	        if (!isServerSide) {
	          if (!window.clientStates) {
	            window.clientStates = {};
	          }

	          clientStates = window.clientStates;
	        }

	        var _loop = function _loop(_providerKey) {
	          var state = states[_providerKey];
	          var providerInstance = providerInstances[_providerKey];

	          if (providerInstance) {
	            if (providerInstance.store.setState) {
	              settingStates.push(function () {
	                return providerInstance.store.setState(state);
	              });
	            }
	          } else {
	            if (clientStates) {
	              clientStates[_providerKey] = state;
	            }

	            gettingInstances.push(state);
	          }
	        };

	        for (var _providerKey in states) {
	          _loop(_providerKey);
	        }

	        // now that `clientStates` are cached...
	        while (gettingInstances.length) {
	          getInstance(gettingInstances.shift());
	        }
	        while (settingStates.length) {
	          settingStates.shift()();
	        }
	      };

	      var find = function find(props, doInstantiate, callback) {
	        if (arguments.length === 2) {
	          callback = doInstantiate;
	          doInstantiate = false;
	        }

	        handleQueries(getTempFauxInstance(fauxInstance, props), function () {
	          if (!doInstantiate) {
	            callback(props.query ? props.result : props.results);
	            return;
	          }

	          if (props.query) {
	            getResultInstances(props.result, callback);
	            return;
	          }

	          var results = props.results;

	          var resultsInstances = {};
	          var resultsKeys = results && Object.keys(results);
	          var semaphore = resultsKeys && resultsKeys.length;
	          function clear() {
	            if (--semaphore === 0) {
	              callback(resultsInstances);
	            }
	          }

	          if (!semaphore) {
	            semaphore = 1;
	            clear();
	          }

	          resultsKeys.forEach(function (resultKey) {
	            resultsInstances[resultKey] = [];

	            getResultInstances(results[resultKey], function (resultInstances) {
	              resultsInstances[resultKey] = resultInstances;
	              clear();
	            });
	          });
	        });
	      };

	      provider.hasThunk = true;

	      if (provider.wait && !Array.isArray(provider.wait)) {
	        provider.wait = [provider.wait];
	      }

	      if (provider.clear && !Array.isArray(provider.clear)) {
	        provider.clear = [provider.clear];
	      }

	      var providerApi = {
	        getInstance: getInstance,
	        getInstances: getInstances,
	        createInstance: createInstance,
	        createInstances: createInstances,
	        setStates: setStates,
	        find: find
	      };

	      (0, _keyConcats.unshiftMiddleware)({ provider: provider }, function (_ref) {
	        var dispatch = _ref.dispatch;
	        var getState = _ref.getState;

	        return function (next) {
	          return function (action) {
	            if (typeof action !== 'function') {
	              return next(action);
	            }

	            if (provider.wait) {
	              provider.wait.forEach(function (fn) {
	                return fn();
	              });
	            }

	            return action(function (action) {
	              var state = store.getState();
	              var storeChanged = false;

	              dispatch(action);

	              if (provider.clear) {
	                storeChanged = state !== store.getState();
	                provider.clear.forEach(function (fn) {
	                  return fn(storeChanged);
	                });
	              }
	            }, getState, providerApi);
	          };
	        };
	      });
	    })();
	  }

	  if (provider.wait) {
	    provider.wait.forEach(function (fn) {
	      return fn();
	    });
	  }

	  providerInstance = Object.create(provider);
	  providerInstance.providerKey = providerKey;
	  providerInstance.isStatic = isStatic;

	  var store = (0, _createProviderStore2.default)(providerInstance, storeKey, createState, createState ? function (state) {
	    var _providerInstance = providerInstance;
	    var onReady = _providerInstance.onReady;


	    providerInstance = instantiateProvider(getTempFauxInstance(fauxInstance, state), provider, undefined, function (createdInstance) {
	      if (Array.isArray(onReady)) {
	        onReady.forEach(function (fn) {
	          return fn(createdInstance);
	        });
	      } else if (onReady) {
	        onReady(createdInstance);
	      }
	    });
	  } : null,
	  // TODO: we need a better way to create + replicate
	  creator && creator.store);

	  var initialState = store.getState();
	  var _providerInstance2 = providerInstance;
	  var actions = _providerInstance2.actions;

	  var actionCreators = {};
	  var setKey = store.setKey;

	  if (setKey) {
	    store.setKey = function (newKey, readyCallback) {
	      if (provider.wait) {
	        provider.wait.forEach(function (fn) {
	          return fn();
	        });
	      }

	      setKey(newKey, function () {
	        if (Array.isArray(providerInstance.onReady)) {
	          providerInstance.onReady.forEach(function (fn) {
	            return fn(providerInstance);
	          });
	        } else if (providerInstance.onReady) {
	          providerInstance.onReady(providerInstance);
	        }

	        if (readyCallback) {
	          readyCallback();
	        }

	        if (provider.clear) {
	          provider.clear.forEach(function (fn) {
	            return fn(true);
	          });
	        }
	      });
	    };
	  }

	  var _loop2 = function _loop2(actionKey) {
	    actionCreators[actionKey] = function () {
	      return store.dispatch(actions[actionKey].apply(this, arguments));
	    };
	  };

	  for (var actionKey in actions) {
	    _loop2(actionKey);
	  }

	  providerInstance.store = store;
	  providerInstance.actionCreators = actionCreators;

	  if (!createState) {
	    if (provider.isGlobal) {
	      globalProviderInstances[providerKey] = providerInstance;
	    }
	    if (providerInstances) {
	      providerInstances[providerKey] = providerInstance;
	    }
	    if (!provider.instances) {
	      provider.instances = [];
	    }
	    provider.instances.push(providerInstance);
	  }

	  if (provider.subscribers) {
	    Object.keys(provider.subscribers).forEach(function (key) {
	      var handler = provider.subscribers[key];
	      var subProvider = providers[key];
	      function callHandler() {
	        var subProviderInstances = subProvider && subProvider.instances;

	        if (subProviderInstances) {
	          subProviderInstances.forEach(function (subProviderInstance) {
	            handler(providerInstance, subProviderInstance);
	          });
	        }
	      }

	      if (subProvider) {
	        if (!subProvider.subscribeTo) {
	          subProvider.subscribeTo = {};
	        }
	        if (!subProvider.subscribeTo[provider.key]) {
	          subProvider.subscribeTo[provider.key] = handler;
	        }
	      }

	      providerInstance.store.subscribe(callHandler);
	      callHandler();
	    });
	  }

	  if (provider.subscribeTo) {
	    Object.keys(provider.subscribeTo).forEach(function (key) {
	      var handler = provider.subscribeTo[key];
	      var supProvider = providers[key];

	      if (!supProvider) {
	        return;
	      }

	      if (!supProvider.subscribers) {
	        supProvider.subscribers = {};
	      }
	      if (!supProvider.subscribers[provider.key]) {
	        supProvider.subscribers[provider.key] = handler;

	        if (supProvider.instances) {
	          supProvider.instances.forEach(function (supProviderInstance) {
	            supProviderInstance.store.subscribe(function () {
	              provider.instances.forEach(function (providerInstance) {
	                handler(supProviderInstance, providerInstance);
	              });
	            });
	          });
	        }
	      }

	      if (supProvider.instances) {
	        supProvider.instances.forEach(function (supProviderInstance) {
	          handler(supProviderInstance, providerInstance);
	        });
	      }
	    });
	  }

	  if (!createState) {
	    if (Array.isArray(providerInstance.onInstantiated)) {
	      providerInstance.onInstantiated.forEach(function (fn) {
	        return fn(providerInstance);
	      });
	    } else if (providerInstance.onInstantiated) {
	      providerInstance.onInstantiated(providerInstance);
	    }
	  }

	  (0, _keyConcats.unshiftOnReady)({ providerInstance: providerInstance }, function () {
	    providerInstance.ready = true;
	  });

	  if (readyCallback) {
	    (0, _keyConcats.pushOnReady)({ providerInstance: providerInstance }, readyCallback);
	  }

	  function done() {
	    if (Array.isArray(providerInstance.onReady)) {
	      providerInstance.onReady.forEach(function (fn) {
	        return fn(providerInstance);
	      });
	    } else if (providerInstance.onReady) {
	      providerInstance.onReady(providerInstance);
	    }

	    if (provider.clear) {
	      (function () {
	        var storeChanged = initialState !== providerInstance.store.getState();
	        provider.clear.forEach(function (fn) {
	          return fn(storeChanged);
	        });
	      })();
	    }
	  }

	  if (provider.replication && store.onReady && !store.initializedReplication) {
	    store.onReady(done);
	  } else {
	    done();
	  }

	  return providerInstance;
	}

	function getContext(fauxInstance) {
	  if (!fauxInstance.context) {
	    fauxInstance.context = {};
	  }

	  return fauxInstance.context;
	}

	function getTempFauxInstance(fauxInstance, props) {
	  return {
	    props: props,
	    context: getContext(fauxInstance),
	    providers: getProviders(fauxInstance),
	    providerInstances: getProviderInstances(fauxInstance),
	    activeQueries: getActiveQueries(fauxInstance),
	    queryResults: getQueryResults(fauxInstance),
	    partialStates: getPartialStates(fauxInstance)
	  };
	}

	function getFromContextOrProps(fauxInstance, key, defaultValue) {
	  if (typeof fauxInstance[key] === 'undefined') {
	    var props = fauxInstance.props;

	    var context = getContext(fauxInstance);

	    if (typeof props[key] !== 'undefined') {
	      fauxInstance[key] = props[key];
	    } else if (typeof context[key] !== 'undefined') {
	      fauxInstance[key] = context[key];
	    } else {
	      fauxInstance[key] = defaultValue;
	    }
	  }

	  return fauxInstance[key];
	}

	function getProviders(fauxInstance) {
	  return getFromContextOrProps(fauxInstance, 'providers', {});
	}

	function getProviderInstances(fauxInstance) {
	  return getFromContextOrProps(fauxInstance, 'providerInstances', {});
	}

	function getActiveQueries(fauxInstance) {
	  return getFromContextOrProps(fauxInstance, 'activeQueries', {});
	}

	function getQueryResults(fauxInstance) {
	  return getFromContextOrProps(fauxInstance, 'queryResults', {});
	}

	function getPartialStates(fauxInstance) {
	  return getFromContextOrProps(fauxInstance, 'partialStates', {});
	}

	function getFunctionOrObject(fauxInstance, key) {
	  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (typeof fauxInstance[key] !== 'undefined') {
	    return fauxInstance[key];
	  }

	  var value = fauxInstance.props[key];

	  if (typeof value === 'function') {
	    value = value(fauxInstance);
	  }

	  fauxInstance[key] = value || defaultValue;

	  return fauxInstance[key];
	}

	function getQueries(fauxInstance) {
	  if (typeof fauxInstance.queries !== 'undefined') {
	    return fauxInstance.queries;
	  }

	  var props = fauxInstance.props;
	  var relevantProviders = fauxInstance.relevantProviders;

	  var providers = getProviders(fauxInstance);
	  var query = getQuery(fauxInstance);
	  var queries = getFunctionOrObject(fauxInstance, 'queries');
	  var hasQueries = false;

	  if (query) {
	    // we need to map the query to relevant provider(s)
	    if (!queries) {
	      queries = {};
	    } else if (typeof props.queries !== 'function') {
	      queries = _extends({}, queries);
	    }

	    for (var key in providers) {
	      var provider = providers[key];
	      var queryKeys = (0, _getRelevantKeys2.default)(provider.reducers, query);

	      if (queryKeys.length) {
	        // provider is relevant, so we map it within the queries object
	        if (!queries[key]) {
	          queries[key] = {};
	        }

	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = queryKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var queryKey = _step.value;

	            queries[key][queryKey] = query[queryKey];
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	    }
	  }

	  for (var _key in queries) {
	    var _query = queries[_key];

	    if (typeof _query === 'function') {
	      queries[_key] = _query(fauxInstance);
	    }

	    // make sure each provider is instantiated
	    instantiateProvider(fauxInstance, providers[_key]);
	    hasQueries = true;
	  }

	  if (!hasQueries) {
	    queries = null;

	    if (props.query) {
	      props.result = null;
	    }

	    if (props.queries) {
	      props.results = {};
	    }
	  }

	  fauxInstance.queries = queries;
	  return queries;
	}

	function getQuery(fauxInstance) {
	  return getFunctionOrObject(fauxInstance, 'query');
	}

	function getQueryOptions(fauxInstance) {
	  return getFunctionOrObject(fauxInstance, 'queryOptions');
	}

	function getQueriesOptions(fauxInstance) {
	  return getFunctionOrObject(fauxInstance, 'queriesOptions', {});
	}

	// gets all `handleQuery` functions within replicators
	function getQueryHandlers(provider) {
	  var queryHandlers = [];
	  var replication = provider.replication;


	  if (replication) {
	    if (!Array.isArray(replication)) {
	      replication = [replication];
	    }

	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;

	    try {
	      for (var _iterator2 = replication[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var _step2$value = _step2.value;
	        var replicator = _step2$value.replicator;
	        var reducerKeys = _step2$value.reducerKeys;
	        var baseQuery = _step2$value.baseQuery;
	        var baseQueryOptions = _step2$value.baseQueryOptions;

	        if (replicator) {
	          if (!Array.isArray(replicator)) {
	            replicator = [replicator];
	          }

	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;

	          try {
	            for (var _iterator3 = replicator[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              var handleQuery = _step3.value.handleQuery;

	              if (handleQuery) {
	                queryHandlers.push({
	                  handleQuery: handleQuery,
	                  reducerKeys: reducerKeys || Object.keys(provider.reducers),
	                  baseQuery: baseQuery,
	                  baseQueryOptions: baseQueryOptions
	                });
	              }
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	  }

	  return queryHandlers;
	}

	function getMergedResult(mergedResult, result) {
	  if (Array.isArray(result)) {
	    return [].concat(_toConsumableArray(mergedResult || []), _toConsumableArray(result));
	  } else if (result && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result.constructor === Object) {
	    return _extends({}, mergedResult || {}, result);
	  } else if (typeof result !== 'undefined') {
	    return result;
	  } else {
	    return mergedResult;
	  }
	}

	function resultsEqual(result, previousResult) {
	  if (result === previousResult) {
	    return true;
	  }

	  if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) !== (typeof previousResult === 'undefined' ? 'undefined' : _typeof(previousResult))) {
	    return false;
	  }

	  if (Array.isArray(result)) {
	    if (Array.isArray(previousResult)) {
	      var i = 0;
	      var length = result.length;

	      if (length !== previousResult.length) {
	        return false;
	      }

	      while (i < length) {
	        if (!(0, _shallowEqual2.default)(result[i], previousResult[i])) {
	          return false;
	        }

	        i++;
	      }
	    } else {
	      return false;
	    }
	  } else if (Array.isArray(previousResult)) {
	    return false;
	  }

	  return (0, _shallowEqual2.default)(result, previousResult);
	}

	// this is admittedly a mess... :(
	// we're accounting for both synchronous and asynchronous query handling
	// where asynchronous results will override the synchronous results
	function handleQueries(fauxInstance, callback, previousResults) {
	  var doUpdate = false;
	  var queries = getQueries(fauxInstance);

	  if (!queries) {
	    if (callback) {
	      callback(doUpdate);
	    }

	    return false;
	  }

	  var props = fauxInstance.props;

	  var context = getContext(fauxInstance);
	  var originalResult = props.result;
	  var originalResults = props.results;

	  var validQuery = false;

	  // for determining whether or not we should update
	  if (!previousResults) {
	    previousResults = _extends({}, props.results);
	  }

	  // get what we need to handle the queries
	  var query = getQuery(fauxInstance);
	  var queryOptions = getQueryOptions(fauxInstance);
	  var queriesOptions = getQueriesOptions(fauxInstance);
	  var activeQueries = getActiveQueries(fauxInstance);
	  var queryResults = getQueryResults(fauxInstance);
	  var partialStates = getPartialStates(fauxInstance);
	  var providers = getProviders(fauxInstance);
	  var providerInstances = getProviderInstances(fauxInstance);

	  // TODO: we should probably do something better at some point
	  var setPartialStates = function setPartialStates(provider, result) {
	    if (!result || !isServerSide) {
	      return;
	    }

	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;

	    try {
	      for (var _iterator4 = result[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	        var partialState = _step4.value;

	        var providerKey = provider.key;

	        if (typeof providerKey === 'function') {
	          providerKey = providerKey({ props: partialState, context: context });
	        }

	        if (providerKey !== null && !providerInstances[providerKey]) {
	          partialStates[providerKey] = partialState;
	        }
	      }
	    } catch (err) {
	      _didIteratorError4 = true;
	      _iteratorError4 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion4 && _iterator4.return) {
	          _iterator4.return();
	        }
	      } finally {
	        if (_didIteratorError4) {
	          throw _iteratorError4;
	        }
	      }
	    }
	  };

	  // most queries should be async
	  var queryCount = Object.keys(queries).length;
	  var queryClear = function queryClear() {
	    if (--queryCount === 0) {
	      // at this point we have all our results
	      if (callback) {
	        callback(doUpdate);
	      }
	    }
	  };

	  // merge each result into `props.result` if using `props.query`
	  var setMergedResult = function setMergedResult(result) {
	    if (props.query) {
	      props.result = getMergedResult(props.result, result);
	    }
	  };

	  // go ahead and set null value if using `props.query`
	  if (props.query) {
	    props.result = null;
	  }

	  // results start out as an empty object
	  props.results = {};

	  // check each query
	  Object.keys(queries).forEach(function (key) {
	    var provider = providers[key];
	    var queryHandlers = getQueryHandlers(provider);
	    var handlerCount = queryHandlers.length;

	    // no handlers?  Y U DO DIS?
	    if (!handlerCount) {
	      queryClear();
	      return;
	    }

	    validQuery = true;

	    // let the provider know we're waiting for all of the handlers to finish
	    if (Array.isArray(provider.wait)) {
	      provider.wait.forEach(function (fn) {
	        return fn();
	      });
	    } else if (provider.wait) {
	      provider.wait();
	    }

	    // here we determine the `resultKey` used for caching the results
	    // in the current context
	    var query = queries[key];
	    var options = queryOptions || queriesOptions[key] || {};
	    var resultKey = JSON.stringify({ query: query, options: options });
	    var queryResult = queryResults[resultKey];
	    var queryResultExists = typeof queryResult !== 'undefined';

	    // subscribe to all of this provider's instances' stores for requeries
	    subscribeToAll(key, provider, fauxInstance, resultKey, query, callback);

	    // result handler for both sync and async queries
	    var setResult = function setResult(result) {
	      var first = activeQueries[resultKey].values().next().value;
	      var leader = setResult === first;
	      var previousResult = queryResultExists ? queryResult : previousResults[key];
	      var asyncReset = setResult.asyncReset;

	      // if new result, set `doUpdate` flag

	      if (!doUpdate && !resultsEqual(result, previousResult)) {
	        doUpdate = true;
	      }

	      // a special `asyncReset` flag is set if async handler is detected;
	      // we want async results to override sync
	      if (asyncReset) {
	        // this should only occur once, at the start of setting async results
	        setResult.asyncReset = false;

	        props.results = {};

	        if (props.query) {
	          props.result = null;
	        }
	      }

	      props.results[key] = result;
	      previousResults[key] = result;
	      queryResults[resultKey] = result;
	      setMergedResult(result);

	      // if this handler is the leader, we pass the result onto the others
	      if (leader && activeQueries[resultKey]) {
	        activeQueries[resultKey].forEach(function (otherSetResult) {
	          if (otherSetResult !== setResult) {
	            otherSetResult(result);
	          }
	        });
	      }

	      if (--handlerCount === 0) {
	        // handler is done, so remove self
	        activeQueries[resultKey].delete(setResult);

	        // if there are no handlers remaining, this query is no longer active
	        if (!activeQueries[resultKey].size) {
	          delete activeQueries[resultKey];
	          setPartialStates(provider, result);
	        }

	        // no more query handlers, so let the provider know we're done
	        if (Array.isArray(provider.clear)) {
	          provider.clear.forEach(function (fn) {
	            return fn(doUpdate);
	          });
	        } else if (provider.clear) {
	          provider.clear(doUpdate);
	        }

	        // and this query is clear
	        queryClear();

	        // we want to remove the cached query results on the client/tests
	        // so that it will always update
	        if (!isServerSide || isTesting) {
	          delete queryResults[resultKey];
	        }
	      }
	    };

	    var setError = function setError(error) {
	      console.error(error);
	    };

	    // this query is currently taking place, make the handler follow the leader
	    if (activeQueries[resultKey]) {
	      activeQueries[resultKey].add(setResult);
	      return;
	    }

	    // this is a new query, so this handler is a leader;
	    // other handlers matching this `resultKey` will check
	    // if the query is active and become a follower
	    activeQueries[resultKey] = new Set();
	    activeQueries[resultKey].add(setResult);

	    // already have our query result cached?
	    // no point in calling any handlers; go ahead and set the result
	    if (queryResultExists) {
	      handlerCount = 1;
	      setResult(queryResult);
	      return;
	    }

	    // now we need to run the query through each `handleQuery` function,
	    // which may or may not be synchronous
	    queryHandlers.forEach(function (_ref2) {
	      var handleQuery = _ref2.handleQuery;
	      var reducerKeys = _ref2.reducerKeys;
	      var baseQuery = _ref2.baseQuery;
	      var baseQueryOptions = _ref2.baseQueryOptions;

	      // we can determine whether or not its synchronous by checking the 
	      // `handlerCount` immediately after `handleQuery` is called
	      var handlerCountBefore = handlerCount;

	      // normalize the query + options so that people can be lazy
	      var normalizedQuery = _extends({}, baseQuery, query);
	      var normalizedOptions = _extends({}, baseQueryOptions, options);

	      if (typeof normalizedOptions.select === 'undefined') {
	        normalizedOptions.select = reducerKeys === true ? Object.keys(provider.reducers) : reducerKeys;
	      } else if (!Array.isArray(normalizedOptions.select)) {
	        normalizedOptions.select = [normalizedOptions.select];
	      }

	      if (Array.isArray(normalizedOptions.select)) {
	        for (var reducerKey in normalizedQuery) {
	          if (normalizedOptions.select.indexOf(reducerKey) < 0) {
	            normalizedOptions.select.push(reducerKey);
	          }
	        }
	      }

	      handleQuery({
	        query: normalizedQuery,
	        options: normalizedOptions,
	        setResult: setResult,
	        setError: setError
	      });

	      if (handlerCount === handlerCountBefore) {
	        // asynchronous query, so we set the `asyncReset` flags to true
	        // only if they haven't been set to false yet
	        activeQueries[resultKey].forEach(function (setResult) {
	          setResult.asyncReset = setResult.asyncReset !== false;
	        });
	      }
	    });
	  });

	  if (!validQuery) {
	    props.result = originalResult;
	    props.results = originalResults;
	  }

	  return validQuery;
	}

	function subscribeToAll(key, provider, fauxInstance, resultKey, query, callback) {
	  if (isServerSide || !fauxInstance.props.__wrapper) {
	    return;
	  }

	  fauxInstance.requeryCallback = callback;

	  if (!provider.subscribedFauxInstances) {
	    provider.subscribedFauxInstances = {};
	  }

	  if (provider.subscribedFauxInstances[resultKey]) {
	    provider.subscribedFauxInstances[resultKey].add(fauxInstance);
	    return;
	  }

	  var subscribedFauxInstances = new Set();
	  provider.subscribedFauxInstances[resultKey] = subscribedFauxInstances;
	  subscribedFauxInstances.add(fauxInstance);

	  var timeout = void 0;
	  var requery = function requery(providerInstance) {
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = subscribedFauxInstances[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var _fauxInstance = _step5.value;

	          if (_fauxInstance.props.__wrapper.unmounted) {
	            subscribedFauxInstances.delete(_fauxInstance);
	          } else {
	            handleQueries(_fauxInstance, _fauxInstance.requeryCallback);
	          }
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	    });
	  };

	  (0, _keyConcats.pushOnReady)({ provider: provider }, requery);

	  if (!provider.subscriber) {
	    provider.subscriber = {};
	  }

	  var subscriber = provider.subscriber[key];
	  provider.subscriber[key] = function (providerInstance, providerInstance2) {
	    if (subscriber) {
	      subscriber(providerInstance, providerInstance2);
	    }

	    if (shouldRequery(providerInstance, query)) {
	      requery(providerInstance);
	    }
	  };

	  if (provider.instances) {
	    provider.instances.forEach(function (providerInstance) {
	      providerInstance.store.subscribe(function () {
	        if (shouldRequery(providerInstance, query)) {
	          requery(providerInstance);
	        }
	      });
	    });
	  }
	}

	function shouldRequery(providerInstance, query) {
	  var currentState = providerInstance.store.getState();
	  var lastQueriedState = providerInstance.lastQueriedState;


	  providerInstance.lastQueriedState = currentState;

	  if (!lastQueriedState) {
	    return true;
	  }

	  if (currentState !== lastQueriedState) {
	    if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	      for (var key in query) {
	        if (currentState[key] !== lastQueriedState[key]) {
	          return true;
	        }
	      }
	    } else {
	      return true;
	    }
	  }

	  return false;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unshiftClear = exports.pushClear = exports.unshiftWait = exports.pushWait = exports.unshiftReplicator = exports.pushReplicator = exports.unshiftReplication = exports.pushReplication = exports.unshiftOnReady = exports.pushOnReady = exports.unshiftOnInstantiated = exports.pushOnInstantiated = exports.unshiftEnhancer = exports.pushEnhancer = exports.unshiftMiddleware = exports.pushMiddleware = undefined;

	var _createKeyConcat = __webpack_require__(2);

	var _createKeyConcat2 = _interopRequireDefault(_createKeyConcat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var middlewareKey = 'middleware';
	var pushMiddleware = exports.pushMiddleware = (0, _createKeyConcat2.default)(middlewareKey);
	var unshiftMiddleware = exports.unshiftMiddleware = (0, _createKeyConcat2.default)(middlewareKey, true);

	var enhancerKey = 'enhancer';
	var pushEnhancer = exports.pushEnhancer = (0, _createKeyConcat2.default)(enhancerKey);
	var unshiftEnhancer = exports.unshiftEnhancer = (0, _createKeyConcat2.default)(enhancerKey, true);

	var onInstantiatedKey = 'onInstantiated';
	var pushOnInstantiated = exports.pushOnInstantiated = (0, _createKeyConcat2.default)(onInstantiatedKey);
	var unshiftOnInstantiated = exports.unshiftOnInstantiated = (0, _createKeyConcat2.default)(onInstantiatedKey, true);

	var onReadyKey = 'onReady';
	var pushOnReady = exports.pushOnReady = (0, _createKeyConcat2.default)(onReadyKey);
	var unshiftOnReady = exports.unshiftOnReady = (0, _createKeyConcat2.default)(onReadyKey, true);

	var replicationKey = 'replication';
	var pushReplication = exports.pushReplication = (0, _createKeyConcat2.default)(replicationKey);
	var unshiftReplication = exports.unshiftReplication = (0, _createKeyConcat2.default)(replicationKey, true);

	var replicatorKey = [replicationKey, 'replicator'];
	var pushReplicator = exports.pushReplicator = (0, _createKeyConcat2.default)(replicatorKey);
	var unshiftReplicator = exports.unshiftReplicator = (0, _createKeyConcat2.default)(replicatorKey, true);

	var waitKey = 'wait';
	var pushWait = exports.pushWait = (0, _createKeyConcat2.default)(waitKey);
	var unshiftWait = exports.unshiftWait = (0, _createKeyConcat2.default)(waitKey, true);

	var clearKey = 'clear';
	var pushClear = exports.pushClear = (0, _createKeyConcat2.default)(clearKey);
	var unshiftClear = exports.unshiftClear = (0, _createKeyConcat2.default)(clearKey, true);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = provide;
	exports.reloadFunctions = reloadFunctions;
	exports.reloadProviders = reloadProviders;

	var _react = __webpack_require__(10);

	var _react2 = _interopRequireDefault(_react);

	var _hoistNonReactStatics = __webpack_require__(8);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _shallowEqual = __webpack_require__(1);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _getRelevantKeys = __webpack_require__(4);

	var _getRelevantKeys2 = _interopRequireDefault(_getRelevantKeys);

	var _instantiateProvider = __webpack_require__(5);

	var _instantiateProvider2 = _interopRequireDefault(_instantiateProvider);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var isServerSide = typeof window === 'undefined';
	var allComponentInstances = [];

	var contextTypes = {
	  providers: _react.PropTypes.object,
	  providerInstances: _react.PropTypes.object,
	  activeQueries: _react.PropTypes.object,
	  queryResults: _react.PropTypes.object,
	  partialStates: _react.PropTypes.object,
	  forceDeepUpdate: _react.PropTypes.bool
	};

	function provide(ComponentClass) {
	  var _class, _temp;

	  if (ComponentClass.ComponentClass) {
	    return ComponentClass;
	  }

	  var componentName = ComponentClass.displayName || ComponentClass.name;

	  function getDisplayName() {
	    var providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    return 'Provide' + componentName + '(' + Object.keys(providers).join(',') + ')';
	  }

	  var Provide = (_temp = _class = function (_Component) {
	    _inherits(Provide, _Component);

	    _createClass(Provide, [{
	      key: 'getChildContext',
	      value: function getChildContext() {
	        return {
	          providers: this.getProviders(),
	          providerInstances: this.getProviderInstances(),
	          activeQueries: this.getActiveQueries(),
	          queryResults: this.getQueryResults(),
	          partialStates: this.getPartialStates(),
	          forceDeepUpdate: this.forceDeepUpdate
	        };
	      }
	    }, {
	      key: 'getProviders',
	      value: function getProviders() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        this.providers = this.providers || props.providers || context.providers || {};

	        return this.providers;
	      }
	    }, {
	      key: 'getProviderInstances',
	      value: function getProviderInstances() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        this.providerInstances = this.providerInstances || props.providerInstances || context.providerInstances || {};

	        return this.providerInstances;
	      }
	    }, {
	      key: 'getActiveQueries',
	      value: function getActiveQueries() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        this.activeQueries = this.activeQueries || props.activeQueries || context.activeQueries || {};

	        return this.activeQueries;
	      }
	    }, {
	      key: 'getQueryResults',
	      value: function getQueryResults() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        this.queryResults = this.queryResults || props.queryResults || context.queryResults || {};

	        return this.queryResults;
	      }
	    }, {
	      key: 'getPartialStates',
	      value: function getPartialStates() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        this.partialStates = this.partialStates || props.partialStates || context.partialStates || {};

	        return this.partialStates;
	      }
	    }]);

	    function Provide(props, context) {
	      _classCallCheck(this, Provide);

	      var _this = _possibleConstructorReturn(this, (Provide.__proto__ || Object.getPrototypeOf(Provide)).call(this, props));

	      _this.render = isServerSide ? function () {
	        var wrappedInstance = _this.getWrappedInstance();

	        _this.deinitialize();
	        return wrappedInstance;
	      } : function () {
	        return _this.getWrappedInstance();
	      };


	      if (!isServerSide && !context.providers) {
	        window.rootInstance = _this;
	        _this.initializeClientStates(props, context);
	      }

	      _this.renders = 0;
	      _this.componentName = componentName;
	      _this.unmounted = true;
	      _this.initialize(props, context);
	      return _this;
	    }

	    _createClass(Provide, [{
	      key: 'componentDidMount',
	      value: function componentDidMount() {
	        this.unmounted = isServerSide;
	      }
	    }, {
	      key: 'componentWillUnmount',
	      value: function componentWillUnmount() {
	        this.unmounted = true;
	        this.deinitialize();
	      }
	    }, {
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        if (!(0, _shallowEqual2.default)(nextProps, this.props)) {
	          this.deinitialize();
	          this.initialize(nextProps, this.context);
	          this.receivedNewProps = true;
	        }
	      }
	    }, {
	      key: 'shouldComponentUpdate',
	      value: function shouldComponentUpdate() {
	        if (this.forceDeepUpdate || this.context.forceDeepUpdate) {
	          return true;
	        } else if (this.receivedNewProps) {
	          this.receivedNewProps = false;
	          return true;
	        } else {
	          return false;
	        }
	      }
	    }, {
	      key: 'update',
	      value: function update() {
	        if (!this.unmounted) {
	          this.forceUpdate();
	        }
	      }

	      // TODO: improve this

	    }, {
	      key: 'initializeClientStates',
	      value: function initializeClientStates() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;
	        var _window = window;
	        var clientStates = _window.clientStates;

	        var fauxInstance = this.getFauxInstance(props, context);
	        var providers = this.getProviders(props, context);
	        var findProvider = function findProvider(props) {
	          for (var key in providers) {
	            var provider = providers[key];

	            if ((0, _getRelevantKeys2.default)(provider.reducers, props).length) {
	              if (typeof provider.defaultKey === 'undefined') {
	                provider.defaultKey = key;
	              }
	              if (typeof provider.key === 'undefined') {
	                provider.key = provider.defaultKey;
	              }

	              return provider;
	            }
	          }
	        };

	        if (clientStates) {
	          for (var providerKey in clientStates) {
	            var state = clientStates[providerKey];

	            (0, _instantiateProvider2.default)((0, _instantiateProvider.getTempFauxInstance)(fauxInstance, state), findProvider(state));
	          }
	        }
	      }
	    }, {
	      key: 'initialize',
	      value: function initialize() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        var providers = this.getProviders(props, context);

	        this.relevantProviders = {};

	        for (var key in providers) {
	          var provider = providers[key];
	          var shouldSubscribe = false;

	          if (typeof provider.defaultKey === 'undefined') {
	            provider.defaultKey = key;
	          }
	          if (typeof provider.key === 'undefined') {
	            provider.key = provider.defaultKey;
	          }

	          this.assignActionCreators(props, context, provider);

	          if (this.assignReducers(props, context, provider)) {
	            shouldSubscribe = true;
	          }

	          if (this.assignMergers(props, context, provider)) {
	            shouldSubscribe = true;
	          }

	          if (shouldSubscribe) {
	            this.subscribeToProvider(props, context, provider);
	          }
	        }

	        this.handleQueries(props, context);
	        this.setDisplayName(props, context);

	        if (this.doUpdate) {
	          this.update();
	        }
	      }
	    }, {
	      key: 'deinitialize',
	      value: function deinitialize() {
	        this.unsubscribe();

	        delete this.relevantProviders;
	        delete this.componentProps;
	        delete this.fauxInstance;
	        delete this.subbedAll;
	        delete this.query;
	        delete this.queryOptions;
	        delete this.queries;
	        delete this.queriesOptions;
	        delete this.subscriptions;
	        delete this.mergers;
	        delete this.wrappedInstance;
	      }
	    }, {
	      key: 'unsubscribe',
	      value: function unsubscribe() {
	        var subscriptions = this.getSubscriptions();

	        while (subscriptions.length) {
	          var unsubscribe = subscriptions.shift();

	          unsubscribe();
	        }
	      }
	    }, {
	      key: 'setDisplayName',
	      value: function setDisplayName(props, context) {
	        Provide.displayName = getDisplayName(this.relevantProviders);
	      }
	    }, {
	      key: 'getComponentProps',
	      value: function getComponentProps() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

	        if (!this.componentProps) {
	          this.componentProps = _extends({}, ComponentClass.defaultProps, props, { __wrapper: this
	          });

	          if (!this.componentProps.ref && ComponentClass.prototype.render) {
	            this.componentProps.ref = 'wrappedInstance';
	          }
	        }

	        return this.componentProps;
	      }
	    }, {
	      key: 'getFauxInstance',
	      value: function getFauxInstance(props, context) {
	        if (!this.fauxInstance) {
	          var componentProps = this.getComponentProps(props, context);

	          this.getProviders(props, context);
	          this.getProviderInstances(props, context);
	          this.getActiveQueries(props, context);
	          this.getQueryResults(props, context);
	          this.getPartialStates(props, context);
	          this.getSubscriptions(props, context);
	          this.fauxInstance = _extends({}, this, { props: componentProps });
	        }

	        this.fauxInstance.context = context;

	        return this.fauxInstance;
	      }
	    }, {
	      key: 'getSubscriptions',
	      value: function getSubscriptions() {
	        if (!this.subscriptions) {
	          this.subscriptions = [];
	        }

	        return this.subscriptions;
	      }
	    }, {
	      key: 'getMergers',
	      value: function getMergers() {
	        if (!this.mergers) {
	          this.mergers = {};
	        }

	        return this.mergers;
	      }
	    }, {
	      key: 'getWrappedInstance',
	      value: function getWrappedInstance() {
	        if (this.context.forceDeepUpdate) {
	          this.doUpdate = true;
	        }

	        if (!this.wrappedInstance || this.doUpdate) {
	          this.renders++;
	          this.doUpdate = false;
	          this.wrappedInstance = _react2.default.createElement(ComponentClass, this.getComponentProps());
	        }

	        return this.wrappedInstance;
	      }
	    }, {
	      key: 'getProviderInstance',
	      value: function getProviderInstance(props, context, provider, getReducerKeys) {
	        return (0, _instantiateProvider2.default)({
	          fauxInstance: this.getFauxInstance(props, context),
	          provider: provider,
	          getReducerKeys: getReducerKeys
	        });
	      }
	    }, {
	      key: 'assignActionCreators',
	      value: function assignActionCreators(props, context, provider) {
	        var actionKeys = (0, _getRelevantKeys2.default)(provider.actions, ComponentClass.propTypes);

	        if (!actionKeys.length) {
	          return false;
	        }

	        var componentProps = this.getComponentProps(props, context);

	        var _getProviderInstance = this.getProviderInstance(props, context, provider, true);

	        var actionCreators = _getProviderInstance.actionCreators;

	        // assign relevant action creators to wrapped component's props

	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = actionKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var actionKey = _step.value;

	            if (!props[actionKey]) {
	              componentProps[actionKey] = actionCreators[actionKey];
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        return true;
	      }
	    }, {
	      key: 'assignReducers',
	      value: function assignReducers(props, context, provider) {
	        var _this2 = this;

	        var reducerKeys = (0, _getRelevantKeys2.default)(provider.reducers, ComponentClass.propTypes);

	        if (!reducerKeys.length) {
	          return false;
	        }

	        var getReducerKeys = {};
	        var shouldSubscribe = false;

	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = reducerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var _reducerKey = _step2.value;

	            if (!props[_reducerKey]) {
	              getReducerKeys[_reducerKey] = true;
	              shouldSubscribe = true;
	            }
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }

	        if (!shouldSubscribe) {
	          return false;
	        }

	        var subscriptions = this.getSubscriptions();
	        var componentProps = this.getComponentProps(props, context);

	        var _getProviderInstance2 = this.getProviderInstance(props, context, provider, getReducerKeys);

	        var store = _getProviderInstance2.store;

	        var state = store.getState();

	        // copy the relevant states to the wrapped component's props
	        // and whenever some state changes, update (mutate) the wrapped props
	        // and raise the `doUpdate` flag to indicate that the component
	        // should be updated after the action has taken place

	        var _loop = function _loop(reducerKey) {
	          componentProps[reducerKey] = state[reducerKey];

	          subscriptions.push(store.watch(reducerKey, function (nextState) {
	            componentProps[reducerKey] = nextState;
	            _this2.doUpdate = true;
	          }));
	        };

	        for (var reducerKey in getReducerKeys) {
	          _loop(reducerKey);
	        }

	        return true;
	      }
	    }, {
	      key: 'assignMergers',
	      value: function assignMergers(props, context, provider) {
	        var _this3 = this;

	        var merge = provider.merge;

	        var mergeKeys = (0, _getRelevantKeys2.default)(merge, ComponentClass.propTypes);

	        if (!mergeKeys.length) {
	          return false;
	        }

	        var getReducerKeys = {};
	        var shouldSubscribe = false;

	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;

	        try {
	          for (var _iterator3 = mergeKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var mergeKey = _step3.value;

	            if (!props[mergeKey]) {
	              var merger = merge[mergeKey];

	              var _iteratorNormalCompletion5 = true;
	              var _didIteratorError5 = false;
	              var _iteratorError5 = undefined;

	              try {
	                for (var _iterator5 = merger.keys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                  var reducerKey = _step5.value;

	                  getReducerKeys[reducerKey] = true;
	                  shouldSubscribe = true;
	                }
	              } catch (err) {
	                _didIteratorError5 = true;
	                _iteratorError5 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                    _iterator5.return();
	                  }
	                } finally {
	                  if (_didIteratorError5) {
	                    throw _iteratorError5;
	                  }
	                }
	              }
	            }
	          }
	        } catch (err) {
	          _didIteratorError3 = true;
	          _iteratorError3 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	              _iterator3.return();
	            }
	          } finally {
	            if (_didIteratorError3) {
	              throw _iteratorError3;
	            }
	          }
	        }

	        if (!shouldSubscribe) {
	          return false;
	        }

	        var mergers = this.getMergers();
	        var subscriptions = this.getSubscriptions();
	        var componentProps = this.getComponentProps(props, context);

	        var _getProviderInstance3 = this.getProviderInstance(props, context, provider, getReducerKeys);

	        var store = _getProviderInstance3.store;

	        var state = store.getState();

	        // some of the wrapped component's props might depend on some state,
	        // possibly merged with props and/or context,
	        // so we watch for changes to certain `keys`
	        // and only update props when those `keys` have changed
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;

	        try {
	          var _loop2 = function _loop2() {
	            var mergeKey = _step4.value;

	            if (!props[mergeKey]) {
	              (function () {
	                var merger = merge[mergeKey];

	                componentProps[mergeKey] = merger.get(state, componentProps, context);

	                var _iteratorNormalCompletion6 = true;
	                var _didIteratorError6 = false;
	                var _iteratorError6 = undefined;

	                try {
	                  for (var _iterator6 = merger.keys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	                    var _reducerKey2 = _step6.value;

	                    subscriptions.push(store.watch(_reducerKey2, function (nextState) {
	                      // we store the merger temporarily so that we may
	                      // `get` the value only after the action has completed
	                      mergers[mergeKey] = merger;
	                      _this3.doMerge = true;
	                    }));
	                  }
	                } catch (err) {
	                  _didIteratorError6 = true;
	                  _iteratorError6 = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                      _iterator6.return();
	                    }
	                  } finally {
	                    if (_didIteratorError6) {
	                      throw _iteratorError6;
	                    }
	                  }
	                }
	              })();
	            }
	          };

	          for (var _iterator4 = mergeKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            _loop2();
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }

	        return true;
	      }
	    }, {
	      key: 'subscribeToProvider',
	      value: function subscribeToProvider(props, context, provider) {
	        var _this4 = this;

	        var subscriptions = this.getSubscriptions();

	        var _getProviderInstance4 = this.getProviderInstance(props, context, provider);

	        var store = _getProviderInstance4.store;

	        // if any states are relevant, we subscribe to the provider's store;
	        // and since we're reflecting any changes to relevant states
	        // by mutating `componentProps` and raising the `doUpdate` flag,
	        // it's more efficient to simply call `forceUpdate` here

	        subscriptions.push(store.subscribe(function () {
	          if (_this4.doMerge) {
	            var mergers = _this4.getMergers();
	            var componentProps = _this4.getComponentProps(props, context);
	            var state = store.getState();

	            // this is where we `get` any new values which depend on
	            // some state, possibly merged with props and/or context
	            for (var mergeKey in mergers) {
	              var get = mergers[mergeKey].get;

	              var value = get(state, componentProps, context);

	              if (componentProps[mergeKey] !== value) {
	                componentProps[mergeKey] = value;
	                _this4.doUpdate = true;
	              }

	              delete mergers[mergeKey];
	            }

	            _this4.doMerge = false;
	          }

	          if (_this4.doUpdate) {
	            _this4.handleQueries(props, context);
	            _this4.setDisplayName(props, context);
	            _this4.update();
	          }
	        }));
	      }
	    }, {
	      key: 'handleQueries',
	      value: function handleQueries(props, context) {
	        var _this5 = this;

	        var fauxInstance = this.getFauxInstance(props, context);

	        return (0, _instantiateProvider.handleQueries)(fauxInstance, function (doUpdate) {
	          if (doUpdate) {
	            // TODO: should mergers be checked (again) ??
	            _this5.doUpdate = true;
	            _this5.update();
	          }
	        });
	      }
	    }]);

	    return Provide;
	  }(_react.Component), _class.ComponentClass = ComponentClass, _class.displayName = getDisplayName(), _class.propTypes = contextTypes, _class.contextTypes = contextTypes, _class.childContextTypes = contextTypes, _temp);

	  if (true) {
	    (function () {
	      var componentInstances = ComponentClass.__componentInstances;

	      if (typeof componentInstances === 'undefined') {
	        componentInstances = new Set();
	        ComponentClass.__componentInstances = componentInstances;
	        allComponentInstances.push(componentInstances);
	      }

	      ComponentClass.Provide = Provide;
	      ComponentClass.setComponentClass = function (NextClass) {
	        componentInstances = ComponentClass.__componentInstances;
	        NextClass.__componentInstances = componentInstances;
	        ComponentClass = NextClass;
	        Provide.ComponentClass = ComponentClass;
	        componentName = ComponentClass.displayName || ComponentClass.name;
	      };

	      Provide.prototype.componentDidMount = function () {
	        this.unmounted = isServerSide;
	        componentInstances.add(this);
	      };

	      Provide.prototype.componentWillUnmount = function () {
	        this.unmounted = true;
	        this.deinitialize();
	        componentInstances.delete(this);
	      };

	      Provide.prototype.reinitialize = function (props, context, NextClass) {
	        var _this6 = this;

	        if (NextClass) {
	          this.setComponentClass(NextClass);
	        }

	        setTimeout(function () {
	          _this6.doUpdate = true;
	          _this6.deinitialize();
	          _this6.initialize(props, context);
	        });
	      };

	      Provide.prototype.setComponentClass = function (NextClass) {
	        Provide.setComponentClass(NextClass);
	        this.componentName = componentName;
	      };

	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;

	      try {
	        for (var _iterator7 = componentInstances[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var componentInstance = _step7.value;
	          var props = componentInstance.props;
	          var context = componentInstance.context;


	          componentInstance.reinitialize(props, context, ComponentClass);
	        }
	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }
	    })();
	  }

	  return (0, _hoistNonReactStatics2.default)(Provide, ComponentClass);
	}

	function reloadFunctions(oldFunctions, newFunctions) {
	  for (var key in newFunctions) {
	    var newFunction = newFunctions[key];
	    var oldFunction = oldFunctions[key];

	    if (typeof newFunction === 'function' && newFunction.propTypes && !newFunction.Provide && oldFunction && oldFunction.Provide) {
	      newFunction.Provide = provide(newFunction);
	      oldFunction.setComponentClass(newFunction);
	      newFunction.setComponentClass = oldFunction.setComponentClass;

	      var _iteratorNormalCompletion8 = true;
	      var _didIteratorError8 = false;
	      var _iteratorError8 = undefined;

	      try {
	        for (var _iterator8 = oldFunction.__componentInstances[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	          var componentInstance = _step8.value;
	          var props = componentInstance.props;
	          var context = componentInstance.context;


	          componentInstance.forceDeepUpdate = true;
	          componentInstance.reinitialize(props, context, newFunction);
	          componentInstance.forceDeepUpdate = false;
	        }
	      } catch (err) {
	        _didIteratorError8 = true;
	        _iteratorError8 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion8 && _iterator8.return) {
	            _iterator8.return();
	          }
	        } finally {
	          if (_didIteratorError8) {
	            throw _iteratorError8;
	          }
	        }
	      }
	    }
	  }

	  if (false) {
	    console.warn('You should only use `reloadInstances` in development!');
	  }
	}

	function reloadProviders(providers, providerInstances) {
	  var _window2 = window;
	  var rootInstance = _window2.rootInstance;
	  var clientStates = _window2.clientStates;
	  var oldProviders = rootInstance.providers;
	  var oldProviderInstances = rootInstance.providerInstances;


	  for (var key in providers) {
	    var provider = providers[key];
	    var oldProvider = oldProviders[key];

	    if (!providers.replication && oldProvider && oldProvider.replication) {
	      provider.replication = oldProvider.replication;
	    }
	  }

	  for (var providerKey in oldProviderInstances) {
	    var oldProviderInstance = oldProviderInstances[providerKey];

	    if (clientStates) {
	      clientStates[providerKey] = oldProviderInstance.store.getState();
	    }

	    delete oldProviderInstances[providerKey];
	  }

	  rootInstance.providers = providers;
	  rootInstance.providerInstances = providerInstances || oldProviderInstances;
	  rootInstance.reinitialize(rootInstance.props, rootInstance.context);

	  var _iteratorNormalCompletion9 = true;
	  var _didIteratorError9 = false;
	  var _iteratorError9 = undefined;

	  try {
	    for (var _iterator9 = allComponentInstances[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	      var componentInstances = _step9.value;
	      var _iteratorNormalCompletion10 = true;
	      var _didIteratorError10 = false;
	      var _iteratorError10 = undefined;

	      try {
	        for (var _iterator10 = componentInstances[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	          var componentInstance = _step10.value;
	          var props = componentInstance.props;
	          var context = componentInstance.context;


	          if (componentInstance !== rootInstance) {
	            context.providers = rootInstance.providers;
	            context.providerInstances = rootInstance.providerInstances;
	            componentInstance.providers = rootInstance.providers;
	            componentInstance.providerInstances = rootInstance.providerInstances;
	            componentInstance.reinitialize(props, context);
	          }
	        }
	      } catch (err) {
	        _didIteratorError10 = true;
	        _iteratorError10 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion10 && _iterator10.return) {
	            _iterator10.return();
	          }
	        } finally {
	          if (_didIteratorError10) {
	            throw _iteratorError10;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError9 = true;
	    _iteratorError9 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion9 && _iterator9.return) {
	        _iterator9.return();
	      }
	    } finally {
	      if (_didIteratorError9) {
	        throw _iteratorError9;
	      }
	    }
	  }

	  if (false) {
	    console.warn('You should only use `reloadProviders` in development!');
	  }
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};

	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);

	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {

	                }
	            }
	        }
	    }

	    return targetComponent;
	};


/***/ },
/* 9 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_10__;

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }
/******/ ])
});
;